class I{layers;constructor(j){this.layers=j??[]}use(j){return new I([...this.layers,j])}handler(j){return async(H)=>{const G={},B={};for(let D of this.layers){const z=await D({ctx:H,data:G,props:B});if(z===void 0)continue;if("notFound"in z||"redirect"in z)return z;if(z.data)Object.assign(G,z.data);if(z.props)Object.assign(B,z.props)}if(j){const D=await j({ctx:H,data:G,props:B});if("notFound"in D||"redirect"in D)return D;Object.assign(B,await D.props)}return{props:B}}}}var K=()=>new I,N=(j)=>j,O=()=>(j)=>j,Q=()=>new I,R=(j)=>j,T=()=>(j)=>j;class J{layers;constructor(j){this.layers=j??[]}use(j){return new J([...this.layers,j])}handler(j){return async(H,G)=>{const B={};for(let D of this.layers){const z=await D({req:H,res:G,data:B});if(z===void 0)continue;if("stop"in z&&z.stop)return;if("data"in z)Object.assign(B,z.data)}return await j({req:H,res:G,data:B})}}}var V=()=>new J,X=(j)=>j,Y=()=>(j)=>j;export{Q as staticMiddleware,T as staticLayerWithContext,R as staticLayer,K as serverMiddleware,O as serverLayerWithContext,N as serverLayer,V as apiMiddleware,Y as apiLayerWithContext,X as apiLayer};
